/**
 * Scanner for SHC language.
 * Tokenizes SHC source code into tokens for parsing.
 *
 * @author SWY
 */

/* Token type constants matching SHC enum */
fun TOKEN_FUN() : int { return 0; }
fun TOKEN_IF() : int { return 1; }
fun TOKEN_ELSE() : int { return 2; }
fun TOKEN_WHILE() : int { return 3; }
fun TOKEN_RETURN() : int { return 4; }
fun TOKEN_BREAK() : int { return 5; }
fun TOKEN_CONTINUE() : int { return 6; }
fun TOKEN_VOID() : int { return 7; }
fun TOKEN_INT() : int { return 8; }
fun TOKEN_CHAR() : int { return 9; }

fun TOKEN_AND() : int { return 10; }
fun TOKEN_OR() : int { return 11; }
fun TOKEN_NOT() : int { return 12; }

fun TOKEN_ADD() : int { return 13; }
fun TOKEN_SUBTRACT() : int { return 14; }
fun TOKEN_MULTIPLY() : int { return 15; }
fun TOKEN_DIVIDE() : int { return 16; }
fun TOKEN_MOD() : int { return 17; }

fun TOKEN_ASSIGN() : int { return 18; }
fun TOKEN_EQUAL() : int { return 19; }
fun TOKEN_NEQ() : int { return 20; }
fun TOKEN_LESS() : int { return 21; }
fun TOKEN_GREATER() : int { return 22; }
fun TOKEN_LEQ() : int { return 23; }
fun TOKEN_GEQ() : int { return 24; }

fun TOKEN_AMP() : int { return 25; }

fun TOKEN_COLON() : int { return 26; }
fun TOKEN_SEMICOLON() : int { return 27; }
fun TOKEN_COMMA() : int { return 28; }
fun TOKEN_LPAREN() : int { return 29; }
fun TOKEN_RPAREN() : int { return 30; }
fun TOKEN_LSQUARE() : int { return 31; }
fun TOKEN_RSQUARE() : int { return 32; }
fun TOKEN_LCURL() : int { return 33; }
fun TOKEN_RCURL() : int { return 34; }

fun TOKEN_ID() : int { return 35; }
fun TOKEN_STRING_LITERAL() : int { return 36; }
fun TOKEN_INT_LITERAL() : int { return 37; }
fun TOKEN_CHAR_LITERAL() : int { return 38; }
fun TOKEN_BOOL_LITERAL() : int { return 39; }
fun TOKEN_TRUE() : int { return 40; }
fun TOKEN_FALSE() : int { return 41; }

fun TOKEN_EOS() : int { return 42; }
fun TOKEN_ERROR() : int { return 43; }

/* Global scanner state */
input_buffer : ^char;
current_pos : int;
line_number : int;
char_position : int;
current_token : int;
token_value : ^char;
token_int_value : int;

/**
 * Initialize scanner with input buffer.
 *
 * @param buffer - source code buffer
 */
fun initScanner(buffer : ^char) : void {
    input_buffer = buffer;
    current_pos = 0;
    line_number = 1;
    char_position = 0;
    current_token = TOKEN_EOS();
    token_value = malloc(256);
}

/**
 * Get current character without advancing.
 */
fun peekChar() : char {
    temp : ^char;
    temp = input_buffer + current_pos;
    return ^temp;
}

/**
 * Get character at offset from current position.
 *
 * @param offset - number of positions ahead
 */
fun peekAhead(offset : int) : char {
    temp : ^char;
    temp = input_buffer + current_pos + offset;
    return ^temp;
}

/**
 * Advance position by n characters.
 *
 * @param n - number of characters to skip
 */
fun advance(n : int) : void {
    current_pos = current_pos + n;
    char_position = char_position + n;
}

/**
 * Check if at end of input.
 */
fun atEnd() : int {
    return peekChar() == '\0';
}

/**
 * Check if character is a digit (0-9).
 *
 * @param c - character to check
 */
fun isDigit(c : char) : int {
    return (c >= '0' && c <= '9');
}

/**
 * Check if character is a letter (a-z, A-Z).
 *
 * @param c - character to check
 */
fun isLetter(c : char) : int {
    return ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));
}

/**
 * Check if character is whitespace (space, tab, newline, carriage return).
 *
 * @param c - character to check
 */
fun isWhitespace(c : char) : int {
    return (c == ' ' || c == '\t' || c == '\n' || c == '\r');
}

/**
 * Check if character can start an identifier.
 *
 * @param c - character to check
 */
fun isIdentStart(c : char) : int {
    return (isLetter(c) || c == '_');
}

/**
 * Check if character can be part of an identifier.
 *
 * @param c - character to check
 */
fun isIdentPart(c : char) : int {
    return (isLetter(c) || isDigit(c) || c == '_');
}

/**
 * Skip whitespace characters.
 */
fun skipWhitespace() : void {
    c : char;
    c = peekChar();

    while (atEnd() == 0 && isWhitespace(c)) {
        if (c == '\n') {
            line_number = line_number + 1;
            char_position = 0;
        }
        advance(1);
        c = peekChar();
    }
}

/**
 * Compare two strings for equality.
 *
 * @param s1 - first string
 * @param s2 - second string
 */
fun strEqual(s1 : ^char, s2 : ^char) : int {
    i : int;
    temp1 : ^char;
    temp2 : ^char;
    c1 : char;
    c2 : char;

    i = 0;

    while (1) {
        temp1 = s1 + i;
        temp2 = s2 + i;
        c1 = ^temp1;
        c2 = ^temp2;

        if (c1 == '\0' || c2 == '\0') {
            break;
        }

        if (c1 != c2) {
            return 0;
        }
        i = i + 1;
    }

    return (c1 == '\0' && c2 == '\0');
}

/**
 * Check if identifier matches a keyword.
 *
 * @param ident - identifier to check
 */
fun matchKeyword(ident : ^char) : int {
    if (strEqual(ident, "fun")) { return TOKEN_FUN(); }
    if (strEqual(ident, "if")) { return TOKEN_IF(); }
    if (strEqual(ident, "else")) { return TOKEN_ELSE(); }
    if (strEqual(ident, "while")) { return TOKEN_WHILE(); }
    if (strEqual(ident, "return")) { return TOKEN_RETURN(); }
    if (strEqual(ident, "break")) { return TOKEN_BREAK(); }
    if (strEqual(ident, "continue")) { return TOKEN_CONTINUE(); }
    if (strEqual(ident, "void")) { return TOKEN_VOID(); }
    if (strEqual(ident, "int")) { return TOKEN_INT(); }
    if (strEqual(ident, "char")) { return TOKEN_CHAR(); }
    if (strEqual(ident, "true")) { return TOKEN_TRUE(); }
    if (strEqual(ident, "false")) { return TOKEN_FALSE(); }

    return TOKEN_ID();
}

/**
 * Read identifier or keyword token.
 */
fun readIdentifier() : void {
    i : int;
    c : char;

    i = 0;
    c = peekChar();

    if (isIdentStart(c) == 0) {
        current_token = TOKEN_ERROR();
        return;
    }

    while (isIdentPart(c) && i < 255) {
        temp : ^char;
        temp = token_value + i;
        ^temp = c;
        i = i + 1;
        advance(1);
        c = peekChar();
    }

    temp : ^char;
    temp = token_value + i;
    ^temp = '\0';
    current_token = matchKeyword(token_value);
}

/**
 * Read integer literal token.
 */
fun readNumber() : void {
    c : char;
    value : int;

    c = peekChar();

    if (c == '0') {
        advance(1);
        c = peekChar();
        if (isDigit(c)) {
            current_token = TOKEN_ERROR();
            return;
        }
        token_int_value = 0;
        current_token = TOKEN_INT_LITERAL();
        return;
    }

    if (isDigit(c) == 0) {
        current_token = TOKEN_ERROR();
        return;
    }

    value = 0;
    while (isDigit(c)) {
        value = value * 10 + (c - '0');
        advance(1);
        c = peekChar();
    }

    token_int_value = value;
    current_token = TOKEN_INT_LITERAL();
}

/**
 * Process escape sequence in string or char literal.
 */
fun readEscape() : char {
    c : char;

    advance(1);
    c = peekChar();

    if (c == 'n') { advance(1); return '\n'; }
    if (c == 't') { advance(1); return '\t'; }
    if (c == 'r') { advance(1); return '\r'; }
    if (c == '\\') { advance(1); return '\\'; }
    if (c == '\'') { advance(1); return '\''; }
    if (c == '"') { advance(1); return '"'; }
    if (c == '0') { advance(1); return '\0'; }

    current_token = TOKEN_ERROR();
    return '\0';
}

/**
 * Read string literal token.
 */
fun readString() : void {
    i : int;
    c : char;

    advance(1);
    i = 0;
    c = peekChar();

    while (c != '"' && c != '\0' && c != '\n' && i < 255) {
        temp : ^char;
        temp = token_value + i;
        if (c == '\\') {
            ^temp = readEscape();
            if (current_token == TOKEN_ERROR()) {
                return;
            }
        } else {
            ^temp = c;
            advance(1);
        }
        i = i + 1;
        c = peekChar();
    }

    if (c != '"') {
        current_token = TOKEN_ERROR();
        return;
    }

    advance(1);
    temp : ^char;
    temp = token_value + i;
    ^temp = '\0';
    current_token = TOKEN_STRING_LITERAL();
}

/**
 * Read character literal token.
 */
fun readChar() : void {
    c : char;
    value : char;

    advance(1);
    c = peekChar();

    if (c == '\0' || c == '\n') {
        current_token = TOKEN_ERROR();
        return;
    }

    if (c == '\\') {
        value = readEscape();
        if (current_token == TOKEN_ERROR()) {
            return;
        }
    } else {
        value = c;
        advance(1);
    }

    c = peekChar();
    if (c != '\'') {
        current_token = TOKEN_ERROR();
        return;
    }

    advance(1);
    token_int_value = value;
    current_token = TOKEN_CHAR_LITERAL();
}

/**
 * Skip single-line comment (// to end of line).
 */
fun skipLineComment() : void {
    c : char;

    advance(2);
    c = peekChar();

    while (c != '\n' && c != '\0') {
        advance(1);
        c = peekChar();
    }
}

/**
 * Skip block comment.
 */
fun skipBlockComment() : void {
    c : char;

    advance(2);
    c = peekChar();

    while (atEnd() == 0) {
        if (c == '*' && peekAhead(1) == '/') {
            advance(2);
            return;
        }

        if (c == '\n') {
            line_number = line_number + 1;
            char_position = 0;
        }

        advance(1);
        c = peekChar();
    }

    current_token = TOKEN_ERROR();
}

/**
 * Skip whitespace and comments.
 */
fun skipWhitespaceAndComments() : void {
    c : char;
    progressed : int;

    progressed = 1;

    while (progressed) {
        progressed = 0;

        skipWhitespace();
        c = peekChar();

        if (c == '/' && peekAhead(1) == '/') {
            skipLineComment();
            progressed = 1;
        }

        if (c == '/' && peekAhead(1) == '*') {
            skipBlockComment();
            if (current_token == TOKEN_ERROR()) {
                return;
            }
            progressed = 1;
        }
    }
}

/**
 * Try to read operator or punctuation symbol.
 * Uses maximal munch for multi-character operators.
 */
fun readSymbol() : int {
    c1 : char;
    c2 : char;

    c1 = peekChar();
    c2 = peekAhead(1);

    if (c1 == '=' && c2 == '=') {
        advance(2);
        current_token = TOKEN_EQUAL();
        return 1;
    }

    if (c1 == '!' && c2 == '=') {
        advance(2);
        current_token = TOKEN_NEQ();
        return 1;
    }

    if (c1 == '<' && c2 == '=') {
        advance(2);
        current_token = TOKEN_LEQ();
        return 1;
    }

    if (c1 == '>' && c2 == '=') {
        advance(2);
        current_token = TOKEN_GEQ();
        return 1;
    }

    if (c1 == '&' && c2 == '&') {
        advance(2);
        current_token = TOKEN_AND();
        return 1;
    }

    if (c1 == '|' && c2 == '|') {
        advance(2);
        current_token = TOKEN_OR();
        return 1;
    }

    if (c1 == '+') { advance(1); current_token = TOKEN_ADD(); return 1; }
    if (c1 == '-') { advance(1); current_token = TOKEN_SUBTRACT(); return 1; }
    if (c1 == '*') { advance(1); current_token = TOKEN_MULTIPLY(); return 1; }
    if (c1 == '/') { advance(1); current_token = TOKEN_DIVIDE(); return 1; }
    if (c1 == '%') { advance(1); current_token = TOKEN_MOD(); return 1; }
    if (c1 == '=') { advance(1); current_token = TOKEN_ASSIGN(); return 1; }
    if (c1 == '<') { advance(1); current_token = TOKEN_LESS(); return 1; }
    if (c1 == '>') { advance(1); current_token = TOKEN_GREATER(); return 1; }
    if (c1 == '!') { advance(1); current_token = TOKEN_NOT(); return 1; }
    if (c1 == '&') { advance(1); current_token = TOKEN_AMP(); return 1; }
    if (c1 == '(') { advance(1); current_token = TOKEN_LPAREN(); return 1; }
    if (c1 == ')') { advance(1); current_token = TOKEN_RPAREN(); return 1; }
    if (c1 == '[') { advance(1); current_token = TOKEN_LSQUARE(); return 1; }
    if (c1 == ']') { advance(1); current_token = TOKEN_RSQUARE(); return 1; }
    if (c1 == '{') { advance(1); current_token = TOKEN_LCURL(); return 1; }
    if (c1 == '}') { advance(1); current_token = TOKEN_RCURL(); return 1; }
    if (c1 == ',') { advance(1); current_token = TOKEN_COMMA(); return 1; }
    if (c1 == ';') { advance(1); current_token = TOKEN_SEMICOLON(); return 1; }
    if (c1 == ':') { advance(1); current_token = TOKEN_COLON(); return 1; }

    return 0;
}

/**
 * Advance to next token in the input stream.
 */
fun nextToken() : void {
    c : char;

    skipWhitespaceAndComments();

    if (atEnd()) {
        current_token = TOKEN_EOS();
        return;
    }

    c = peekChar();

    if (readSymbol()) {
        return;
    }

    if (c == '"') {
        readString();
        return;
    }

    if (c == '\'') {
        readChar();
        return;
    }

    if (isDigit(c)) {
        readNumber();
        return;
    }

    if (isIdentStart(c)) {
        readIdentifier();
        return;
    }

    current_token = TOKEN_ERROR();
}

/**
 * Get current token type.
 */
fun getCurrentToken() : int {
    return current_token;
}

/**
 * Get token string value for ID or STRING_LITERAL.
 */
fun getTokenValue() : ^char {
    return token_value;
}

/**
 * Get token integer value for INT_LITERAL or CHAR_LITERAL.
 */
fun getTokenInt() : int {
    return token_int_value;
}

/**
 * Get current line number.
 */
fun getLineNumber() : int {
    return line_number;
}

/**
 * Get current character position.
 */
fun getCharPosition() : int {
    return char_position;
}
/**
 * Parser for SHC language - builds AST from tokens.
 * Part of the self-hosted SHC compiler (Compiler 2).
 *
 * @author SWY
 * @version 1.0
 */

/* ============================================================================
 * NODE TYPE CONSTANTS
 * ============================================================================ */

/* Statement node types */
fun NODE_STMT_IF() : int { return 1; }
fun NODE_STMT_WHILE() : int { return 2; }
fun NODE_STMT_RETURN() : int { return 3; }
fun NODE_STMT_BREAK() : int { return 4; }
fun NODE_STMT_CONTINUE() : int { return 5; }
fun NODE_STMT_DECL() : int { return 6; }
fun NODE_STMT_ASSIGN() : int { return 7; }
fun NODE_STMT_CALL() : int { return 8; }
fun NODE_STMT_BLOCK() : int { return 9; }

/* Expression node types */
fun NODE_EXPR_BINARY() : int { return 20; }
fun NODE_EXPR_UNARY() : int { return 21; }
fun NODE_EXPR_LITERAL() : int { return 22; }
fun NODE_EXPR_VAR() : int { return 23; }
fun NODE_EXPR_CALL() : int { return 24; }
fun NODE_EXPR_PAREN() : int { return 25; }

/* Other node types */
fun NODE_FUNCTION() : int { return 40; }
fun NODE_VARIABLE() : int { return 41; }
fun NODE_PARAM() : int { return 42; }

/* ============================================================================
 * NODE STRUCTURE SIZES (in bytes)
 * ============================================================================ */

/* Memory layout for nodes:
 * All nodes start with: [type:int][line:int][col:int]
 *
 * Statement (if): [type][line][col][cond_ptr][then_ptr][then_count][else_ptr][else_count]
 * Statement (while): [type][line][col][cond_ptr][body_ptr][body_count]
 * Statement (return): [type][line][col][has_value][value_ptr]
 * Statement (decl): [type][line][col][var_ptr]
 * Statement (assign): [type][line][col][lhs_ptr][rhs_ptr]
 * Statement (call): [type][line][col][name_ptr][args_ptr][arg_count]
 *
 * Expression (binary): [type][line][col][operator][left_ptr][right_ptr]
 * Expression (unary): [type][line][col][operator][operand_ptr]
 * Expression (literal): [type][line][col][value_type][int_value]
 * Expression (var): [type][line][col][name_ptr][deref_count]
 * Expression (call): [type][line][col][name_ptr][args_ptr][arg_count]
 *
 * Function: [type][line][col][ret_type][ret_stars][name_ptr][params_ptr][param_count][body_ptr][body_count]
 * Variable: [type][line][col][base_type][stars][name_ptr]
 */

fun STMT_BASE_SIZE() : int { return 12; }    // type + line + col
fun STMT_IF_SIZE() : int { return 44; }
fun STMT_WHILE_SIZE() : int { return 32; }
fun STMT_RETURN_SIZE() : int { return 24; }
fun STMT_SIMPLE_SIZE() : int { return 12; }  // break/continue
fun STMT_DECL_SIZE() : int { return 20; }
fun STMT_ASSIGN_SIZE() : int { return 28; }
fun STMT_CALL_SIZE() : int { return 36; }

fun EXPR_BINARY_SIZE() : int { return 32; }
fun EXPR_UNARY_SIZE() : int { return 24; }
fun EXPR_LITERAL_SIZE() : int { return 24; }
fun EXPR_VAR_SIZE() : int { return 28; }
fun EXPR_CALL_SIZE() : int { return 36; }

fun FUNCTION_SIZE() : int { return 56; }
fun VARIABLE_SIZE() : int { return 28; }

/* ============================================================================
 * GLOBAL PARSER STATE
 * ============================================================================ */

/* Scanner integration state */
parser_current_token : int;
parser_token_value : ^char;
parser_token_int : int;
parser_token_line : int;
parser_token_col : int;

/* Parser state */
parser_functions : ^^int;          // array of function node pointers
parser_function_count : int;
parser_function_capacity : int;

parser_local_vars : ^^int;         // array of variable node pointers
parser_local_var_count : int;
parser_local_var_capacity : int;

parser_error_count : int;

/* ============================================================================
 * SCANNER INTEGRATION (assumes scanner.shc is linked)
 * ============================================================================ */

/**
 * Advance to next token and update parser state.
 */
fun parserNextToken() : void {
    nextToken();  // from scanner.shc
    parser_current_token = getCurrentToken();
    parser_token_value = getTokenValue();
    parser_token_int = getTokenInt();
    parser_token_line = getLineNumber();
    parser_token_col = getCharPosition();
}

/**
 * Initialize parser with source code.
 * @param buffer - source code as string
 */
fun initParser(buffer : ^char) : void {
    // Initialize scanner
    initScanner(buffer);

    // Initialize parser state
    parser_function_capacity = 16;
    parser_functions = malloc(parser_function_capacity * 8);  // array of pointers
    parser_function_count = 0;

    parser_local_var_capacity = 64;
    parser_local_vars = malloc(parser_local_var_capacity * 8);
    parser_local_var_count = 0;

    parser_error_count = 0;

    // Get first token
    parserNextToken();
}

/* ============================================================================
 * PARSER HELPER FUNCTIONS
 * ============================================================================ */

/**
 * Check if current token matches expected type.
 * @param expected - token type to match
 * @return 1 if match, 0 otherwise
 */
fun match(expected : int) : int {
    return parser_current_token == expected;
}

/**
 * Consume current token if it matches expected type.
 * @param expected - token type to match
 * @return 1 if consumed, 0 otherwise
 */
fun consume(expected : int) : int {
    if (match(expected)) {
        parserNextToken();
        return 1;
    }
    return 0;
}

/**
 * Expect a specific token, error if not found.
 * @param expected - token type to expect
 * @param msg - error message
 */
fun expect(expected : int, msg : ^char) : void {
    if (parser_current_token != expected) {
        printError(msg, parser_token_line, parser_token_col);
        parser_error_count = parser_error_count + 1;
        return;
    }
    parserNextToken();
}

/**
 * Expect an identifier token.
 * @return pointer to identifier string (or null on error)
 */
fun expectId() : ^char {
    if (parser_current_token != TOKEN_ID()) {
        printError("Expected identifier", parser_token_line, parser_token_col);
        parser_error_count = parser_error_count + 1;
        return malloc(1);  // empty string
    }
    result : ^char;
    result = parser_token_value;
    parserNextToken();
    return result;
}

/**
 * Print parser error message.
 * @param msg - error message
 * @param line - line number
 * @param col - column number
 */
fun printError(msg : ^char, line : int, col : int) : void {
    puts("ERROR: ");
    puts(msg);
    puts(" at line ");
    // TODO: print line and col numbers
    puts("\n");
}

/* ============================================================================
 * NODE ALLOCATION FUNCTIONS
 * ============================================================================ */

/**
 * Allocate and initialize a statement node.
 * @param type - statement node type
 * @param size - size in bytes
 * @return pointer to allocated node
 */
fun allocStatement(type : int, size : int) : ^int {
    node : ^int;
    temp : ^int;
    node = malloc(size);
    ^node = type;                           // node type
    temp = node + 1;
    ^temp = parser_token_line;              // line
    temp = node + 2;
    ^temp = parser_token_col;               // col
    return node;
}

/**
 * Allocate and initialize an expression node.
 * @param type - expression node type
 * @param size - size in bytes
 * @return pointer to allocated node
 */
fun allocExpression(type : int, size : int) : ^int {
    node : ^int;
    temp : ^int;
    node = malloc(size);
    ^node = type;
    temp = node + 1;
    ^temp = parser_token_line;
    temp = node + 2;
    ^temp = parser_token_col;
    return node;
}

/**
 * Allocate a function node.
 * @return pointer to allocated function node
 */
fun allocFunction() : ^int {
    return allocStatement(NODE_FUNCTION(), FUNCTION_SIZE());
}

/**
 * Allocate a variable node.
 * @return pointer to allocated variable node
 */
fun allocVariable() : ^int {
    node : ^int;
    temp : ^int;
    node = malloc(VARIABLE_SIZE());
    ^node = NODE_VARIABLE();
    temp = node + 1;
    ^temp = parser_token_line;
    temp = node + 2;
    ^temp = parser_token_col;
    return node;
}

/* ============================================================================
 * NODE ACCESSOR FUNCTIONS (getters/setters)
 * ============================================================================ */

/* ============================================================================
 * EXPRESSION NODE ACCESSORS
 * ============================================================================ */

/* Binary expression: [type][line][col][operator][left_ptr][right_ptr] */

fun getBinaryOp(node : ^int) : int {
    temp : ^int;
    temp = node + 3;
    return ^temp;
}

fun setBinaryOp(node : ^int, op : int) : void {
    temp : ^int;
    temp = node + 3;
    ^temp = op;
}

fun getBinaryLeft(node : ^int) : ^int {
    temp : ^^int;
    temp = node + 4;
    return ^temp;
}

fun setBinaryLeft(node : ^int, left : ^int) : void {
    temp : ^^int;
    temp = node + 4;
    ^temp = left;
}

fun getBinaryRight(node : ^int) : ^int {
    temp : ^^int;
    temp = node + 5;
    return ^temp;
}

fun setBinaryRight(node : ^int, right : ^int) : void {
    temp : ^^int;
    temp = node + 5;
    ^temp = right;
}

/* Unary expression: [type][line][col][operator][operand_ptr] */

fun getUnaryOp(node : ^int) : int {
    temp : ^int;
    temp = node + 3;
    return ^temp;
}

fun setUnaryOp(node : ^int, op : int) : void {
    temp : ^int;
    temp = node + 3;
    ^temp = op;
}

fun getUnaryOperand(node : ^int) : ^int {
    temp : ^^int;
    temp = node + 4;
    return ^temp;
}

fun setUnaryOperand(node : ^int, operand : ^int) : void {
    temp : ^^int;
    temp = node + 4;
    ^temp = operand;
}

/* Literal expression: [type][line][col][value_type][int_value] */

fun getLiteralType(node : ^int) : int {
    temp : ^int;
    temp = node + 3;
    return ^temp;
}

fun setLiteralType(node : ^int, valType : int) : void {
    temp : ^int;
    temp = node + 3;
    ^temp = valType;
}

fun getLiteralValue(node : ^int) : int {
    temp : ^int;
    temp = node + 4;
    return ^temp;
}

fun setLiteralValue(node : ^int, val : int) : void {
    temp : ^int;
    temp = node + 4;
    ^temp = val;
}

/* Variable expression: [type][line][col][name_ptr][deref_count] */

fun getVarName(node : ^int) : ^char {
    temp : ^^char;
    temp = node + 3;
    return ^temp;
}

fun setVarName(node : ^int, name : ^char) : void {
    temp : ^^char;
    temp = node + 3;
    ^temp = name;
}

fun getVarDerefCount(node : ^int) : int {
    temp : ^int;
    temp = node + 4;
    return ^temp;
}

fun setVarDerefCount(node : ^int, count : int) : void {
    temp : ^int;
    temp = node + 4;
    ^temp = count;
}

/* Call expression: [type][line][col][name_ptr][args_ptr][arg_count] */

fun getCallName(node : ^int) : ^char {
    temp : ^^char;
    temp = node + 3;
    return ^temp;
}

fun setCallName(node : ^int, name : ^char) : void {
    temp : ^^char;
    temp = node + 3;
    ^temp = name;
}

fun getCallArgs(node : ^int) : ^^int {
    temp : ^^^int;
    temp = node + 4;
    return ^temp;
}

fun setCallArgs(node : ^int, args : ^^int) : void {
    temp : ^^^int;
    temp = node + 4;
    ^temp = args;
}

fun getCallArgCount(node : ^int) : int {
    temp : ^int;
    temp = node + 5;
    return ^temp;
}

fun setCallArgCount(node : ^int, count : int) : void {
    temp : ^int;
    temp = node + 5;
    ^temp = count;
}

/* ============================================================================
 * STATEMENT NODE ACCESSORS
 * ============================================================================ */

/* If statement: [type][line][col][cond_ptr][then_ptr][then_count][else_ptr][else_count] */

fun getIfCondition(node : ^int) : ^int {
    temp : ^^int;
    temp = node + 3;
    return ^temp;
}

fun setIfCondition(node : ^int, cond : ^int) : void {
    temp : ^^int;
    temp = node + 3;
    ^temp = cond;
}

fun getIfThen(node : ^int) : ^^int {
    temp : ^^^int;
    temp = node + 4;
    return ^temp;
}

fun setIfThen(node : ^int, thenBlock : ^^int) : void {
    temp : ^^^int;
    temp = node + 4;
    ^temp = thenBlock;
}

fun getIfThenCount(node : ^int) : int {
    temp : ^int;
    temp = node + 5;
    return ^temp;
}

fun setIfThenCount(node : ^int, count : int) : void {
    temp : ^int;
    temp = node + 5;
    ^temp = count;
}

fun getIfElse(node : ^int) : ^^int {
    temp : ^^^int;
    temp = node + 6;
    return ^temp;
}

fun setIfElse(node : ^int, elseBlock : ^^int) : void {
    temp : ^^^int;
    temp = node + 6;
    ^temp = elseBlock;
}

fun getIfElseCount(node : ^int) : int {
    temp : ^int;
    temp = node + 7;
    return ^temp;
}

fun setIfElseCount(node : ^int, count : int) : void {
    temp : ^int;
    temp = node + 7;
    ^temp = count;
}

/* While statement: [type][line][col][cond_ptr][body_ptr][body_count] */

fun getWhileCondition(node : ^int) : ^int {
    temp : ^^int;
    temp = node + 3;
    return ^temp;
}

fun setWhileCondition(node : ^int, cond : ^int) : void {
    temp : ^^int;
    temp = node + 3;
    ^temp = cond;
}

fun getWhileBody(node : ^int) : ^^int {
    temp : ^^^int;
    temp = node + 4;
    return ^temp;
}

fun setWhileBody(node : ^int, body : ^^int) : void {
    temp : ^^^int;
    temp = node + 4;
    ^temp = body;
}

fun getWhileBodyCount(node : ^int) : int {
    temp : ^int;
    temp = node + 5;
    return ^temp;
}

fun setWhileBodyCount(node : ^int, count : int) : void {
    temp : ^int;
    temp = node + 5;
    ^temp = count;
}

/* Return statement: [type][line][col][has_value][value_ptr] */

fun getReturnHasValue(node : ^int) : int {
    temp : ^int;
    temp = node + 3;
    return ^temp;
}

fun setReturnHasValue(node : ^int, hasVal : int) : void {
    temp : ^int;
    temp = node + 3;
    ^temp = hasVal;
}

fun getReturnValue(node : ^int) : ^int {
    temp : ^^int;
    temp = node + 4;
    return ^temp;
}

fun setReturnValue(node : ^int, val : ^int) : void {
    temp : ^^int;
    temp = node + 4;
    ^temp = val;
}

/* Declaration statement: [type][line][col][var_ptr] */

fun getDeclVariable(node : ^int) : ^int {
    temp : ^^int;
    temp = node + 3;
    return ^temp;
}

fun setDeclVariable(node : ^int, varNode : ^int) : void {
    temp : ^^int;
    temp = node + 3;
    ^temp = varNode;
}

/* Assignment statement: [type][line][col][lhs_ptr][rhs_ptr] */

fun getAssignLhs(node : ^int) : ^int {
    temp : ^^int;
    temp = node + 3;
    return ^temp;
}

fun setAssignLhs(node : ^int, lhs : ^int) : void {
    temp : ^^int;
    temp = node + 3;
    ^temp = lhs;
}

fun getAssignRhs(node : ^int) : ^int {
    temp : ^^int;
    temp = node + 4;
    return ^temp;
}

fun setAssignRhs(node : ^int, rhs : ^int) : void {
    temp : ^^int;
    temp = node + 4;
    ^temp = rhs;
}

/* Call statement: [type][line][col][name_ptr][args_ptr][arg_count] */
/* Note: These are identical to call expression accessors, but included for clarity */

fun getStmtCallName(node : ^int) : ^char {
    temp : ^^char;
    temp = node + 3;
    return ^temp;
}

fun setStmtCallName(node : ^int, name : ^char) : void {
    temp : ^^char;
    temp = node + 3;
    ^temp = name;
}

fun getStmtCallArgs(node : ^int) : ^^int {
    temp : ^^^int;
    temp = node + 4;
    return ^temp;
}

fun setStmtCallArgs(node : ^int, args : ^^int) : void {
    temp : ^^^int;
    temp = node + 4;
    ^temp = args;
}

fun getStmtCallArgCount(node : ^int) : int {
    temp : ^int;
    temp = node + 5;
    return ^temp;
}

fun setStmtCallArgCount(node : ^int, count : int) : void {
    temp : ^int;
    temp = node + 5;
    ^temp = count;
}

/* ============================================================================
 * FUNCTION AND VARIABLE NODE ACCESSORS
 * ============================================================================ */

/* Function: [type][line][col][ret_type][ret_stars][name_ptr][params_ptr][param_count][body_ptr][body_count] */

fun getFunctionRetType(node : ^int) : int {
    temp : ^int;
    temp = node + 3;
    return ^temp;
}

fun setFunctionRetType(node : ^int, retType : int) : void {
    temp : ^int;
    temp = node + 3;
    ^temp = retType;
}

fun getFunctionRetStars(node : ^int) : int {
    temp : ^int;
    temp = node + 4;
    return ^temp;
}

fun setFunctionRetStars(node : ^int, stars : int) : void {
    temp : ^int;
    temp = node + 4;
    ^temp = stars;
}

fun getFunctionName(node : ^int) : ^char {
    temp : ^^char;
    temp = node + 5;
    return ^temp;
}

fun setFunctionName(node : ^int, name : ^char) : void {
    temp : ^^char;
    temp = node + 5;
    ^temp = name;
}

fun getFunctionParams(node : ^int) : ^^int {
    temp : ^^^int;
    temp = node + 6;
    return ^temp;
}

fun setFunctionParams(node : ^int, params : ^^int) : void {
    temp : ^^^int;
    temp = node + 6;
    ^temp = params;
}

fun getFunctionParamCount(node : ^int) : int {
    temp : ^int;
    temp = node + 7;
    return ^temp;
}

fun setFunctionParamCount(node : ^int, count : int) : void {
    temp : ^int;
    temp = node + 7;
    ^temp = count;
}

fun getFunctionBody(node : ^int) : ^^int {
    temp : ^^^int;
    temp = node + 8;
    return ^temp;
}

fun setFunctionBody(node : ^int, body : ^^int) : void {
    temp : ^^^int;
    temp = node + 8;
    ^temp = body;
}

fun getFunctionBodyCount(node : ^int) : int {
    temp : ^int;
    temp = node + 9;
    return ^temp;
}

fun setFunctionBodyCount(node : ^int, count : int) : void {
    temp : ^int;
    temp = node + 9;
    ^temp = count;
}

/* Variable: [type][line][col][base_type][stars][name_ptr] */

fun getVariableBaseType(node : ^int) : int {
    temp : ^int;
    temp = node + 3;
    return ^temp;
}

fun setVariableBaseType(node : ^int, baseType : int) : void {
    temp : ^int;
    temp = node + 3;
    ^temp = baseType;
}

fun getVariableStars(node : ^int) : int {
    temp : ^int;
    temp = node + 4;
    return ^temp;
}

fun setVariableStars(node : ^int, stars : int) : void {
    temp : ^int;
    temp = node + 4;
    ^temp = stars;
}

fun getVariableName(node : ^int) : ^char {
    temp : ^^char;
    temp = node + 5;
    return ^temp;
}

fun setVariableName(node : ^int, name : ^char) : void {
    temp : ^^char;
    temp = node + 5;
    ^temp = name;
}

/* ============================================================================
 * COMMON NODE ACCESSORS
 * ============================================================================ */

/**
 * Get node type (first field of all nodes).
 */
fun getNodeType(node : ^int) : int {
    return ^node;
}

/**
 * Get node line number (second field of all nodes).
 */
fun getNodeLine(node : ^int) : int {
    temp : ^int;
    temp = node + 1;
    return ^temp;
}

/**
 * Get node column number (third field of all nodes).
 */
fun getNodeCol(node : ^int) : int {
    temp : ^int;
    temp = node + 2;
    return ^temp;
}

/* ============================================================================
 * EXPRESSION PARSING FUNCTIONS
 * ============================================================================ */

/**
 * Parse primary expression (highest precedence).
 * Handles: literals, identifiers, function calls, parentheses, dereferences
 * @return expression node pointer
 */
fun parsePrimaryExpression() : ^int {
    node : ^int;
    name : ^char;
    args : ^^int;
    argCount : int;
    argCapacity : int;
    expr : ^int;
    derefCount : int;

    // Integer literal
    if (match(TOKEN_INT_LITERAL())) {
        node = allocExpression(NODE_EXPR_LITERAL(), EXPR_LITERAL_SIZE());
        setLiteralType(node, TOKEN_INT_LITERAL());
        setLiteralValue(node, parser_token_int);
        parserNextToken();
        return node;
    }

    // Character literal
    if (match(TOKEN_CHAR_LITERAL())) {
        node = allocExpression(NODE_EXPR_LITERAL(), EXPR_LITERAL_SIZE());
        setLiteralType(node, TOKEN_CHAR_LITERAL());
        setLiteralValue(node, parser_token_int);
        parserNextToken();
        return node;
    }

    // String literal
    if (match(TOKEN_STRING_LITERAL())) {
        node = allocExpression(NODE_EXPR_LITERAL(), EXPR_LITERAL_SIZE());
        setLiteralType(node, TOKEN_STRING_LITERAL());
        // Store pointer to string value (cast to int)
        setLiteralValue(node, 0);  // TODO: handle string value properly
        parserNextToken();
        return node;
    }

    // Parenthesized expression
    if (match(TOKEN_LPAREN())) {
        parserNextToken();
        expr = parseExpression();
        expect(TOKEN_RPAREN(), "Expected ')'");
        return expr;
    }

    // Pointer dereference: ^expr
    if (match(TOKEN_MULTIPLY())) {  // Using ^ which scans as MULTIPLY
        parserNextToken();
        expr = parsePrimaryExpression();
        // Wrap in a dereference expression
        // For now, treat as unary operation
        node = allocExpression(NODE_EXPR_UNARY(), EXPR_UNARY_SIZE());
        setUnaryOp(node, TOKEN_MULTIPLY());
        setUnaryOperand(node, expr);
        return node;
    }

    // Identifier or function call
    if (match(TOKEN_ID())) {
        name = parser_token_value;
        parserNextToken();

        // Check for function call: ID '(' args ')'
        if (match(TOKEN_LPAREN())) {
            parserNextToken();

            // Parse argument list
            argCapacity = 8;
            args = malloc(argCapacity * 8);  // array of pointers
            argCount = 0;

            if (match(TOKEN_RPAREN()) == 0) {
                // Parse arguments
                while (1) {
                    // Grow array if needed
                    if (argCount >= argCapacity) {
                        argCapacity = argCapacity * 2;
                        // TODO: realloc args array
                    }

                    // Parse argument expression
                    temp : ^^int;
                    temp = args + argCount;
                    ^temp = parseExpression();
                    argCount = argCount + 1;

                    // Check for more arguments
                    if (match(TOKEN_COMMA())) {
                        parserNextToken();
                    } else {
                        break;
                    }
                }
            }

            expect(TOKEN_RPAREN(), "Expected ')'");

            // Create call expression node
            node = allocExpression(NODE_EXPR_CALL(), EXPR_CALL_SIZE());
            setCallName(node, name);
            setCallArgs(node, args);
            setCallArgCount(node, argCount);
            return node;
        }

        // Variable reference (possibly with dereferences)
        derefCount = 0;
        node = allocExpression(NODE_EXPR_VAR(), EXPR_VAR_SIZE());
        setVarName(node, name);
        setVarDerefCount(node, derefCount);
        return node;
    }

    // Error: unexpected token
    printError("Expected expression", parser_token_line, parser_token_col);
    parser_error_count = parser_error_count + 1;
    // Return dummy literal node
    node = allocExpression(NODE_EXPR_LITERAL(), EXPR_LITERAL_SIZE());
    setLiteralType(node, TOKEN_INT_LITERAL());
    setLiteralValue(node, 0);
    return node;
}

/**
 * Parse unary expression.
 * Handles: !, -, &, ^ (address-of and dereference)
 * @return expression node pointer
 */
fun parseUnaryExpression() : ^int {
    node : ^int;
    operand : ^int;
    op : int;

    // Unary minus: -expr
    if (match(TOKEN_SUBTRACT())) {
        op = TOKEN_SUBTRACT();
        parserNextToken();
        operand = parseUnaryExpression();  // Right-associative
        node = allocExpression(NODE_EXPR_UNARY(), EXPR_UNARY_SIZE());
        setUnaryOp(node, op);
        setUnaryOperand(node, operand);
        return node;
    }

    // Logical not: !expr
    if (match(TOKEN_NOT())) {
        op = TOKEN_NOT();
        parserNextToken();
        operand = parseUnaryExpression();  // Right-associative
        node = allocExpression(NODE_EXPR_UNARY(), EXPR_UNARY_SIZE());
        setUnaryOp(node, op);
        setUnaryOperand(node, operand);
        return node;
    }

    // Address-of: &expr
    if (match(TOKEN_AMP())) {
        op = TOKEN_AMP();
        parserNextToken();
        operand = parseUnaryExpression();  // Right-associative
        node = allocExpression(NODE_EXPR_UNARY(), EXPR_UNARY_SIZE());
        setUnaryOp(node, op);
        setUnaryOperand(node, operand);
        return node;
    }

    // Otherwise, parse primary expression
    return parsePrimaryExpression();
}

/**
 * Parse multiplicative expression (*, /, %).
 * Left-associative.
 * @return expression node pointer
 */
fun parseMultiplicativeExpression() : ^int {
    left : ^int;
    right : ^int;
    node : ^int;
    op : int;

    left = parseUnaryExpression();

    while (match(TOKEN_MULTIPLY()) || match(TOKEN_DIVIDE()) || match(TOKEN_MOD())) {
        op = parser_current_token;
        parserNextToken();
        right = parseUnaryExpression();

        // Create binary expression node
        node = allocExpression(NODE_EXPR_BINARY(), EXPR_BINARY_SIZE());
        setBinaryOp(node, op);
        setBinaryLeft(node, left);
        setBinaryRight(node, right);
        left = node;
    }

    return left;
}

/**
 * Parse additive expression (+, -).
 * Left-associative.
 * @return expression node pointer
 */
fun parseAdditiveExpression() : ^int {
    left : ^int;
    right : ^int;
    node : ^int;
    op : int;

    left = parseMultiplicativeExpression();

    while (match(TOKEN_ADD()) || match(TOKEN_SUBTRACT())) {
        op = parser_current_token;
        parserNextToken();
        right = parseMultiplicativeExpression();

        // Create binary expression node
        node = allocExpression(NODE_EXPR_BINARY(), EXPR_BINARY_SIZE());
        setBinaryOp(node, op);
        setBinaryLeft(node, left);
        setBinaryRight(node, right);
        left = node;
    }

    return left;
}

/**
 * Parse relational expression (<, >, <=, >=).
 * Left-associative.
 * @return expression node pointer
 */
fun parseRelationalExpression() : ^int {
    left : ^int;
    right : ^int;
    node : ^int;
    op : int;

    left = parseAdditiveExpression();

    while (match(TOKEN_LESS()) || match(TOKEN_GREATER()) ||
           match(TOKEN_LEQ()) || match(TOKEN_GEQ())) {
        op = parser_current_token;
        parserNextToken();
        right = parseAdditiveExpression();

        // Create binary expression node
        node = allocExpression(NODE_EXPR_BINARY(), EXPR_BINARY_SIZE());
        setBinaryOp(node, op);
        setBinaryLeft(node, left);
        setBinaryRight(node, right);
        left = node;
    }

    return left;
}

/**
 * Parse equality expression (==, !=).
 * Left-associative.
 * @return expression node pointer
 */
fun parseEqualityExpression() : ^int {
    left : ^int;
    right : ^int;
    node : ^int;
    op : int;

    left = parseRelationalExpression();

    while (match(TOKEN_EQUAL()) || match(TOKEN_NEQ())) {
        op = parser_current_token;
        parserNextToken();
        right = parseRelationalExpression();

        // Create binary expression node
        node = allocExpression(NODE_EXPR_BINARY(), EXPR_BINARY_SIZE());
        setBinaryOp(node, op);
        setBinaryLeft(node, left);
        setBinaryRight(node, right);
        left = node;
    }

    return left;
}

/**
 * Parse and expression (&&).
 * Left-associative.
 * @return expression node pointer
 */
fun parseAndExpression() : ^int {
    left : ^int;
    right : ^int;
    node : ^int;
    op : int;

    left = parseEqualityExpression();

    while (match(TOKEN_AND())) {
        op = parser_current_token;
        parserNextToken();
        right = parseEqualityExpression();

        // Create binary expression node
        node = allocExpression(NODE_EXPR_BINARY(), EXPR_BINARY_SIZE());
        setBinaryOp(node, op);
        setBinaryLeft(node, left);
        setBinaryRight(node, right);
        left = node;
    }

    return left;
}

/**
 * Parse or expression (||).
 * Left-associative.
 * @return expression node pointer
 */
fun parseOrExpression() : ^int {
    left : ^int;
    right : ^int;
    node : ^int;
    op : int;

    left = parseAndExpression();

    while (match(TOKEN_OR())) {
        op = parser_current_token;
        parserNextToken();
        right = parseAndExpression();

        // Create binary expression node
        node = allocExpression(NODE_EXPR_BINARY(), EXPR_BINARY_SIZE());
        setBinaryOp(node, op);
        setBinaryLeft(node, left);
        setBinaryRight(node, right);
        left = node;
    }

    return left;
}

/**
 * Parse expression (top-level entry point).
 * @return expression node pointer
 */
fun parseExpression() : ^int {
    return parseOrExpression();
}

/* ============================================================================
 * STATEMENT PARSING FUNCTIONS
 * ============================================================================ */

/**
 * Check if current token can start a statement.
 * @return 1 if token can start statement, 0 otherwise
 */
fun isStatementStart() : int {
    if (match(TOKEN_IF())) { return 1; }
    if (match(TOKEN_WHILE())) { return 1; }
    if (match(TOKEN_RETURN())) { return 1; }
    if (match(TOKEN_BREAK())) { return 1; }
    if (match(TOKEN_CONTINUE())) { return 1; }
    if (match(TOKEN_LCURL())) { return 1; }
    if (match(TOKEN_ID())) { return 1; }
    if (match(TOKEN_SEMICOLON())) { return 1; }
    if (match(TOKEN_MULTIPLY())) { return 1; }  // For ^var = expr
    return 0;
}

/**
 * Parse a sequence of statements until a closing brace or end of input.
 * @return array of statement pointers and count via parser state
 */
fun parseStatementSequence() : ^^int {
    stmts : ^^int;
    stmtCapacity : int;
    stmtCount : int;
    stmt : ^int;
    temp : ^^int;

    // Allocate initial array
    stmtCapacity = 16;
    stmts = malloc(stmtCapacity * 8);
    stmtCount = 0;

    // Parse statements while we can
    while (isStatementStart()) {
        // Grow array if needed
        if (stmtCount >= stmtCapacity) {
            stmtCapacity = stmtCapacity * 2;
            // TODO: realloc stmts array
        }

        // Parse statement and add to array
        stmt = parseStatement();
        temp = stmts + stmtCount;
        ^temp = stmt;
        stmtCount = stmtCount + 1;
    }

    // Store count in parser state (reuse local var count for now)
    parser_local_var_count = stmtCount;
    return stmts;
}

/**
 * Parse a block of statements: { stmt* }
 * @return array of statement pointers
 */
fun parseBlock() : ^^int {
    stmts : ^^int;

    expect(TOKEN_LCURL(), "Expected '{'");
    stmts = parseStatementSequence();
    expect(TOKEN_RCURL(), "Expected '}'");

    return stmts;
}

/**
 * Parse a statement or block (for if/while bodies).
 * @return array of statement pointers
 */
fun parseStatementOrBlock() : ^^int {
    stmts : ^^int;
    stmt : ^int;
    temp : ^^int;

    if (match(TOKEN_LCURL())) {
        return parseBlock();
    }

    // Single statement - wrap in array
    stmts = malloc(8);  // Single pointer
    stmt = parseStatement();
    temp = stmts;
    ^temp = stmt;
    parser_local_var_count = 1;
    return stmts;
}

/**
 * Parse an if statement: if (cond) stmt [else stmt]
 * @return if statement node
 */
fun parseIfStatement() : ^int {
    node : ^int;
    cond : ^int;
    thenBlock : ^^int;
    thenCount : int;
    elseBlock : ^^int;
    elseCount : int;

    expect(TOKEN_IF(), "Expected 'if'");
    expect(TOKEN_LPAREN(), "Expected '('");
    cond = parseExpression();
    expect(TOKEN_RPAREN(), "Expected ')'");

    thenBlock = parseStatementOrBlock();
    thenCount = parser_local_var_count;

    // Check for else clause
    elseCount = 0;
    if (match(TOKEN_ELSE())) {
        parserNextToken();
        elseBlock = parseStatementOrBlock();
        elseCount = parser_local_var_count;
    }

    // Create if statement node
    node = allocStatement(NODE_STMT_IF(), STMT_IF_SIZE());
    setIfCondition(node, cond);
    setIfThen(node, thenBlock);
    setIfThenCount(node, thenCount);
    setIfElse(node, elseBlock);
    setIfElseCount(node, elseCount);

    return node;
}

/**
 * Parse a while statement: while (cond) stmt
 * @return while statement node
 */
fun parseWhileStatement() : ^int {
    node : ^int;
    cond : ^int;
    body : ^^int;
    bodyCount : int;

    expect(TOKEN_WHILE(), "Expected 'while'");
    expect(TOKEN_LPAREN(), "Expected '('");
    cond = parseExpression();
    expect(TOKEN_RPAREN(), "Expected ')'");

    body = parseStatementOrBlock();
    bodyCount = parser_local_var_count;

    // Create while statement node
    node = allocStatement(NODE_STMT_WHILE(), STMT_WHILE_SIZE());
    setWhileCondition(node, cond);
    setWhileBody(node, body);
    setWhileBodyCount(node, bodyCount);

    return node;
}

/**
 * Parse a return statement: return [expr] ;
 * @return return statement node
 */
fun parseReturnStatement() : ^int {
    node : ^int;
    value : ^int;
    hasValue : int;

    expect(TOKEN_RETURN(), "Expected 'return'");

    hasValue = 0;
    if (match(TOKEN_SEMICOLON()) == 0) {
        hasValue = 1;
        value = parseExpression();
    }

    expect(TOKEN_SEMICOLON(), "Expected ';'");

    // Create return statement node
    node = allocStatement(NODE_STMT_RETURN(), STMT_RETURN_SIZE());
    setReturnHasValue(node, hasValue);
    if (hasValue) {
        setReturnValue(node, value);
    }

    return node;
}

/**
 * Parse a break statement: break ;
 * @return break statement node
 */
fun parseBreakStatement() : ^int {
    node : ^int;

    expect(TOKEN_BREAK(), "Expected 'break'");
    expect(TOKEN_SEMICOLON(), "Expected ';'");

    node = allocStatement(NODE_STMT_BREAK(), STMT_SIMPLE_SIZE());
    return node;
}

/**
 * Parse a continue statement: continue ;
 * @return continue statement node
 */
fun parseContinueStatement() : ^int {
    node : ^int;

    expect(TOKEN_CONTINUE(), "Expected 'continue'");
    expect(TOKEN_SEMICOLON(), "Expected ';'");

    node = allocStatement(NODE_STMT_CONTINUE(), STMT_SIMPLE_SIZE());
    return node;
}

/**
 * Parse a variable declaration: name : type ;
 * @return declaration statement node
 */
fun parseDeclaration(name : ^char) : ^int {
    node : ^int;
    varNode : ^int;
    baseType : int;
    stars : int;

    // Expect colon
    expect(TOKEN_COLON(), "Expected ':'");

    // Parse type (simplified - just handle int and char for now)
    stars = 0;
    if (match(TOKEN_MULTIPLY())) {  // ^ for pointer
        stars = 1;
        parserNextToken();
    }

    if (match(TOKEN_INT())) {
        baseType = TOKEN_INT();
        parserNextToken();
    } else if (match(TOKEN_CHAR())) {
        baseType = TOKEN_CHAR();
        parserNextToken();
    } else {
        printError("Expected type", parser_token_line, parser_token_col);
        baseType = TOKEN_INT();
    }

    expect(TOKEN_SEMICOLON(), "Expected ';'");

    // Create variable node
    varNode = allocVariable();
    setVariableBaseType(varNode, baseType);
    setVariableStars(varNode, stars);
    setVariableName(varNode, name);

    // Create declaration statement node
    node = allocStatement(NODE_STMT_DECL(), STMT_DECL_SIZE());
    setDeclVariable(node, varNode);

    return node;
}

/**
 * Parse an assignment statement: lhs = rhs ;
 * @return assignment statement node
 */
fun parseAssignment(lhsExpr : ^int) : ^int {
    node : ^int;
    rhs : ^int;

    expect(TOKEN_ASSIGN(), "Expected '='");
    rhs = parseExpression();
    expect(TOKEN_SEMICOLON(), "Expected ';'");

    // Create assignment statement node
    node = allocStatement(NODE_STMT_ASSIGN(), STMT_ASSIGN_SIZE());
    setAssignLhs(node, lhsExpr);
    setAssignRhs(node, rhs);

    return node;
}

/**
 * Parse a function call statement: name ( args ) ;
 * @return call statement node
 */
fun parseCallStatement(name : ^char) : ^int {
    node : ^int;
    args : ^^int;
    argCount : int;
    argCapacity : int;
    temp : ^^int;

    expect(TOKEN_LPAREN(), "Expected '('");

    // Parse argument list
    argCapacity = 8;
    args = malloc(argCapacity * 8);
    argCount = 0;

    if (match(TOKEN_RPAREN()) == 0) {
        while (1) {
            if (argCount >= argCapacity) {
                argCapacity = argCapacity * 2;
                // TODO: realloc
            }

            temp = args + argCount;
            ^temp = parseExpression();
            argCount = argCount + 1;

            if (match(TOKEN_COMMA())) {
                parserNextToken();
            } else {
                break;
            }
        }
    }

    expect(TOKEN_RPAREN(), "Expected ')'");
    expect(TOKEN_SEMICOLON(), "Expected ';'");

    // Create call statement node
    node = allocStatement(NODE_STMT_CALL(), STMT_CALL_SIZE());
    setStmtCallName(node, name);
    setStmtCallArgs(node, args);
    setStmtCallArgCount(node, argCount);

    return node;
}

/**
 * Parse a single statement.
 * Dispatches to appropriate parser based on current token.
 * @return statement node pointer
 */
fun parseStatement() : ^int {
    name : ^char;
    lhsExpr : ^int;

    // Control flow statements
    if (match(TOKEN_IF())) {
        return parseIfStatement();
    }
    if (match(TOKEN_WHILE())) {
        return parseWhileStatement();
    }
    if (match(TOKEN_RETURN())) {
        return parseReturnStatement();
    }
    if (match(TOKEN_BREAK())) {
        return parseBreakStatement();
    }
    if (match(TOKEN_CONTINUE())) {
        return parseContinueStatement();
    }

    // Block statement
    if (match(TOKEN_LCURL())) {
        // Parse as single block statement (wrap first statement)
        temp : ^^int;
        temp = parseBlock();
        // Return first statement from block
        return ^temp;
    }

    // Empty statement
    if (match(TOKEN_SEMICOLON())) {
        parserNextToken();
        // Return empty break as placeholder
        return allocStatement(NODE_STMT_BREAK(), STMT_SIMPLE_SIZE());
    }

    // ID: could be declaration, assignment, or call
    if (match(TOKEN_ID())) {
        name = parser_token_value;
        parserNextToken();

        // Check for declaration: name : type
        if (match(TOKEN_COLON())) {
            return parseDeclaration(name);
        }

        // Check for call: name ( args )
        if (match(TOKEN_LPAREN())) {
            return parseCallStatement(name);
        }

        // Check for assignment: name = expr
        if (match(TOKEN_ASSIGN())) {
            // Create var expression for LHS
            lhsExpr = allocExpression(NODE_EXPR_VAR(), EXPR_VAR_SIZE());
            setVarName(lhsExpr, name);
            setVarDerefCount(lhsExpr, 0);
            return parseAssignment(lhsExpr);
        }

        printError("Expected ':', '(', or '=' after identifier", parser_token_line, parser_token_col);
        return allocStatement(NODE_STMT_BREAK(), STMT_SIMPLE_SIZE());
    }

    // Pointer dereference assignment: ^var = expr
    if (match(TOKEN_MULTIPLY())) {
        parserNextToken();
        lhsExpr = parsePrimaryExpression();
        // Wrap in dereference
        temp : ^int;
        temp = allocExpression(NODE_EXPR_UNARY(), EXPR_UNARY_SIZE());
        setUnaryOp(temp, TOKEN_MULTIPLY());
        setUnaryOperand(temp, lhsExpr);
        return parseAssignment(temp);
    }

    // Error: unexpected token
    printError("Expected statement", parser_token_line, parser_token_col);
    parser_error_count = parser_error_count + 1;
    return allocStatement(NODE_STMT_BREAK(), STMT_SIMPLE_SIZE());
}

/* ============================================================================
 * FUNCTION AND PROGRAM PARSING
 * ============================================================================ */

/**
 * Parse a type specification: [^]* (int|char|void)
 * Returns base type in parser_token_int and star count in parser_token_col
 */
fun parseType() : void {
    stars : int;
    baseType : int;

    // Count pointer stars (^)
    stars = 0;
    while (match(TOKEN_MULTIPLY())) {  // ^ scans as MULTIPLY
        stars = stars + 1;
        parserNextToken();
    }

    // Parse base type
    if (match(TOKEN_INT())) {
        baseType = TOKEN_INT();
        parserNextToken();
    } else if (match(TOKEN_CHAR())) {
        baseType = TOKEN_CHAR();
        parserNextToken();
    } else if (match(TOKEN_VOID())) {
        baseType = TOKEN_VOID();
        parserNextToken();
    } else {
        printError("Expected type (int, char, or void)", parser_token_line, parser_token_col);
        baseType = TOKEN_INT();
    }

    // Store results in parser globals (hack to return multiple values)
    parser_token_int = baseType;
    parser_token_col = stars;
}

/**
 * Parse a function parameter: name : type
 * @return parameter (variable) node pointer
 */
fun parseParameter() : ^int {
    name : ^char;
    varNode : ^int;
    baseType : int;
    stars : int;

    // Get parameter name
    name = expectId();

    // Expect colon
    expect(TOKEN_COLON(), "Expected ':'");

    // Parse type
    parseType();
    baseType = parser_token_int;
    stars = parser_token_col;

    // Create variable node for parameter
    varNode = allocVariable();
    setVariableBaseType(varNode, baseType);
    setVariableStars(varNode, stars);
    setVariableName(varNode, name);

    return varNode;
}

/**
 * Parse a complete function declaration.
 * @return function node pointer
 */
fun parseFunction() : ^int {
    funcNode : ^int;
    name : ^char;
    retType : int;
    retStars : int;
    params : ^^int;
    paramCapacity : int;
    paramCount : int;
    body : ^^int;
    bodyCount : int;
    temp : ^^int;

    // Expect 'fun' keyword
    expect(TOKEN_FUN(), "Expected 'fun'");

    // Get function name
    name = expectId();

    // Parse parameter list
    expect(TOKEN_LPAREN(), "Expected '('");

    paramCapacity = 8;
    params = malloc(paramCapacity * 8);
    paramCount = 0;

    if (match(TOKEN_RPAREN()) == 0) {
        // Parse parameters
        while (1) {
            if (paramCount >= paramCapacity) {
                paramCapacity = paramCapacity * 2;
                // TODO: realloc
            }

            temp = params + paramCount;
            ^temp = parseParameter();
            paramCount = paramCount + 1;

            if (match(TOKEN_COMMA())) {
                parserNextToken();
            } else {
                break;
            }
        }
    }

    expect(TOKEN_RPAREN(), "Expected ')'");

    // Parse return type
    expect(TOKEN_COLON(), "Expected ':'");
    parseType();
    retType = parser_token_int;
    retStars = parser_token_col;

    // Parse function body
    body = parseBlock();
    bodyCount = parser_local_var_count;

    // Create function node
    funcNode = allocFunction();
    setFunctionRetType(funcNode, retType);
    setFunctionRetStars(funcNode, retStars);
    setFunctionName(funcNode, name);
    setFunctionParams(funcNode, params);
    setFunctionParamCount(funcNode, paramCount);
    setFunctionBody(funcNode, body);
    setFunctionBodyCount(funcNode, bodyCount);

    return funcNode;
}

/**
 * Main parser entry point.
 * @param source - source code string
 * @return number of functions parsed (0 if error)
 */
fun parseProgram(source : ^char) : int {
    funcNode : ^int;
    temp : ^^int;

    initParser(source);

    // Parse all functions
    while (match(TOKEN_FUN())) {
        // Grow array if needed
        if (parser_function_count >= parser_function_capacity) {
            parser_function_capacity = parser_function_capacity * 2;
            // TODO: realloc parser_functions
        }

        // Parse function and add to array
        funcNode = parseFunction();
        temp = parser_functions + parser_function_count;
        ^temp = funcNode;
        parser_function_count = parser_function_count + 1;
    }

    // Check for end of input
    if (match(TOKEN_EOS()) == 0) {
        printError("Expected end of input or function declaration", parser_token_line, parser_token_col);
        parser_error_count = parser_error_count + 1;
    }

    return parser_function_count;
}
// code generator - converts AST to C
// @author SWY

// globals for output
output_buffer : ^char;
output_pos : int;
output_capacity : int;
current_indent : int;

// init output buf
fun initOutputBuffer() : void {
    output_capacity = 16384;
    output_buffer = malloc(output_capacity);
    output_pos = 0;
    current_indent = 0;
}

// add char to buffer
fun appendChar(c : char) : void {
    temp : ^char;

    // grow buffer if needed
    if (output_pos >= output_capacity - 1) {
        output_capacity = output_capacity * 2;
        // TODO fix this later lol
    }

    temp = output_buffer + output_pos;
    ^temp = c;
    output_pos = output_pos + 1;
}

// append string
fun appendString(s : ^char) : void {
    i : int;
    c : char;
    temp : ^char;

    i = 0;
    while (1) {
        temp = s + i;
        c = ^temp;
        if (c == 0) {
            break;
        }
        appendChar(c);
        i = i + 1;
    }
}

// convert int to string
fun appendInt(n : int) : void {
    // negatives
    if (n < 0) {
        appendChar('-');
        n = 0 - n;
    }

    // zero case
    if (n == 0) {
        appendChar('0');
        return;
    }

    // recursive
    if (n >= 10) {
        appendInt(n / 10);
    }
    appendChar('0' + (n % 10));
}

// add indentation
fun appendIndent() : void {
    i : int;
    j : int;
    i = 0;
    while (i < current_indent) {
        j = 0;
        while (j < 4) {
            appendChar(' ');
            j = j + 1;
        }
        i = i + 1;
    }
}

fun indent() : void {
    current_indent = current_indent + 1;
}

fun dedent() : void {
    current_indent = current_indent - 1;
}

// write buffer to stdout
fun flushBuffer() : void {
    temp : ^char;
    temp = output_buffer + output_pos;
    ^temp = 0;
    puts(output_buffer);
}

// compile type spec to C
fun compileType(baseType : int, stars : int) : void {
    i : int;

    // base type
    if (baseType == TOKEN_INT()) {
        appendString("uint64_t");
    } else if (baseType == TOKEN_CHAR()) {
        appendString("uint8_t");
    } else if (baseType == TOKEN_VOID()) {
        appendString("void");
    }

    // pointer stars
    i = 0;
    while (i < stars) {
        appendString(" *");
        i = i + 1;
    }
}

// main entry - compile all functions
fun compile(functions : ^^int, functionCount : int) : void {
    i : int;
    funcNode : ^int;
    temp : ^^int;

    initOutputBuffer();

    // headers
    appendString("#include <stdio.h>\n");
    appendString("#include <stdlib.h>\n");
    appendString("#include <stdint.h>\n\n");

    // compile funcs
    i = 0;
    while (i < functionCount) {
        temp = functions + i;
        funcNode = ^temp;
        compileFunction(funcNode);
        appendChar('\n');
        i = i + 1;
    }

    flushBuffer();
}

// compile literal expr
fun compileLiteral(expr : ^int) : void {
    litType : int;
    value : int;

    litType = getLiteralType(expr);
    value = getLiteralValue(expr);

    if (litType == TOKEN_INT_LITERAL()) {
        appendInt(value);
    } else if (litType == TOKEN_CHAR_LITERAL()) {
        appendChar('\'');
        appendChar(value);
        appendChar('\'');
    } else {
        // TODO strings
        appendString("\"str\"");
    }
}

// compile var reference
fun compileVarExpr(expr : ^int) : void {
    name : ^char;
    name = getVarName(expr);
    appendString(name);
}

// compile binary op
fun compileBinaryExpr(expr : ^int) : void {
    op : int;
    left : ^int;
    right : ^int;

    op = getBinaryOp(expr);
    left = getBinaryLeft(expr);
    right = getBinaryRight(expr);

    appendChar('(');
    compileExpression(left);
    appendChar(' ');

    // operator
    if (op == TOKEN_ADD()) {
        appendChar('+');
    } else if (op == TOKEN_SUBTRACT()) {
        appendChar('-');
    } else if (op == TOKEN_MULTIPLY()) {
        appendChar('*');
    } else if (op == TOKEN_DIVIDE()) {
        appendChar('/');
    } else if (op == TOKEN_MOD()) {
        appendChar('%');
    } else if (op == TOKEN_EQUAL()) {
        appendString("==");
    } else if (op == TOKEN_NEQ()) {
        appendString("!=");
    } else if (op == TOKEN_LESS()) {
        appendChar('<');
    } else if (op == TOKEN_GREATER()) {
        appendChar('>');
    } else if (op == TOKEN_LEQ()) {
        appendString("<=");
    } else if (op == TOKEN_GEQ()) {
        appendString(">=");
    } else if (op == TOKEN_AND()) {
        appendString("&&");
    } else if (op == TOKEN_OR()) {
        appendString("||");
    }

    appendChar(' ');
    compileExpression(right);
    appendChar(')');
}

// compile unary op
fun compileUnaryExpr(expr : ^int) : void {
    op : int;
    operand : ^int;

    op = getUnaryOp(expr);
    operand = getUnaryOperand(expr);

    appendChar('(');

    if (op == TOKEN_NOT()) {
        appendChar('!');
    } else if (op == TOKEN_SUBTRACT()) {
        appendChar('-');
    } else if (op == TOKEN_AMP()) {
        appendChar('&');
    } else if (op == TOKEN_MULTIPLY()) {
        appendChar('*');
    }

    compileExpression(operand);
    appendChar(')');
}

// compile function call
fun compileCallExpr(expr : ^int) : void {
    name : ^char;
    args : ^^int;
    argCount : int;
    i : int;
    temp : ^^int;
    arg : ^int;

    name = getCallName(expr);
    args = getCallArgs(expr);
    argCount = getCallArgCount(expr);

    appendString(name);
    appendChar('(');

    i = 0;
    while (i < argCount) {
        temp = args + i;
        arg = ^temp;
        compileExpression(arg);

        if (i < argCount - 1) {
            appendString(", ");
        }
        i = i + 1;
    }

    appendChar(')');
}

// dispatch expressions
fun compileExpression(expr : ^int) : void {
    nodeType : int;

    nodeType = getNodeType(expr);

    if (nodeType == NODE_EXPR_LITERAL()) {
        compileLiteral(expr);
    } else if (nodeType == NODE_EXPR_VAR()) {
        compileVarExpr(expr);
    } else if (nodeType == NODE_EXPR_BINARY()) {
        compileBinaryExpr(expr);
    } else if (nodeType == NODE_EXPR_UNARY()) {
        compileUnaryExpr(expr);
    } else if (nodeType == NODE_EXPR_CALL()) {
        compileCallExpr(expr);
    }
}

// return stmt
fun compileReturn(stmt : ^int) : void {
    hasValue : int;
    value : ^int;

    appendIndent();
    appendString("return");

    hasValue = getReturnHasValue(stmt);
    if (hasValue) {
        appendChar(' ');
        value = getReturnValue(stmt);
        compileExpression(value);
    }

    appendString(";\n");
}

fun compileBreak() : void {
    appendIndent();
    appendString("break;\n");
}

fun compileContinue() : void {
    appendIndent();
    appendString("continue;\n");
}

// var declaration
fun compileDeclaration(stmt : ^int) : void {
    varNode : ^int;
    baseType : int;
    stars : int;
    name : ^char;

    varNode = getDeclVariable(stmt);
    baseType = getVariableBaseType(varNode);
    stars = getVariableStars(varNode);
    name = getVariableName(varNode);

    appendIndent();
    compileType(baseType, stars);
    appendChar(' ');
    appendString(name);
    appendString(";\n");
}

// assignment
fun compileAssignment(stmt : ^int) : void {
    lhs : ^int;
    rhs : ^int;

    lhs = getAssignLhs(stmt);
    rhs = getAssignRhs(stmt);

    appendIndent();
    compileExpression(lhs);
    appendString(" = ");
    compileExpression(rhs);
    appendString(";\n");
}

// function call stmt
fun compileCallStmt(stmt : ^int) : void {
    name : ^char;
    args : ^^int;
    argCount : int;
    i : int;
    temp : ^^int;
    arg : ^int;

    name = getStmtCallName(stmt);
    args = getStmtCallArgs(stmt);
    argCount = getStmtCallArgCount(stmt);

    appendIndent();
    appendString(name);
    appendChar('(');

    i = 0;
    while (i < argCount) {
        temp = args + i;
        arg = ^temp;
        compileExpression(arg);

        if (i < argCount - 1) {
            appendString(", ");
        }
        i = i + 1;
    }

    appendString(");\n");
}

// if/else stmt
fun compileIf(stmt : ^int) : void {
    cond : ^int;
    thenBlock : ^^int;
    thenCount : int;
    elseBlock : ^^int;
    elseCount : int;

    cond = getIfCondition(stmt);
    thenBlock = getIfThen(stmt);
    thenCount = getIfThenCount(stmt);
    elseBlock = getIfElse(stmt);
    elseCount = getIfElseCount(stmt);

    appendIndent();
    appendString("if (");
    compileExpression(cond);
    appendString(") {\n");

    indent();
    compileStatementBlock(thenBlock, thenCount);
    dedent();

    if (elseCount > 0) {
        appendIndent();
        appendString("} else {\n");
        indent();
        compileStatementBlock(elseBlock, elseCount);
        dedent();
    }

    appendIndent();
    appendString("}\n");
}

// while loop
fun compileWhile(stmt : ^int) : void {
    cond : ^int;
    body : ^^int;
    bodyCount : int;

    cond = getWhileCondition(stmt);
    body = getWhileBody(stmt);
    bodyCount = getWhileBodyCount(stmt);

    appendIndent();
    appendString("while (");
    compileExpression(cond);
    appendString(") {\n");

    indent();
    compileStatementBlock(body, bodyCount);
    dedent();

    appendIndent();
    appendString("}\n");
}

// dispatch statements
fun compileStatement(stmt : ^int) : void {
    nodeType : int;

    nodeType = getNodeType(stmt);

    if (nodeType == NODE_STMT_RETURN()) {
        compileReturn(stmt);
    } else if (nodeType == NODE_STMT_BREAK()) {
        compileBreak();
    } else if (nodeType == NODE_STMT_CONTINUE()) {
        compileContinue();
    } else if (nodeType == NODE_STMT_DECL()) {
        compileDeclaration(stmt);
    } else if (nodeType == NODE_STMT_ASSIGN()) {
        compileAssignment(stmt);
    } else if (nodeType == NODE_STMT_CALL()) {
        compileCallStmt(stmt);
    } else if (nodeType == NODE_STMT_IF()) {
        compileIf(stmt);
    } else if (nodeType == NODE_STMT_WHILE()) {
        compileWhile(stmt);
    }
}

// compile block of stmts
fun compileStatementBlock(stmts : ^^int, count : int) : void {
    i : int;
    temp : ^^int;
    stmt : ^int;

    i = 0;
    while (i < count) {
        temp = stmts + i;
        stmt = ^temp;
        compileStatement(stmt);
        i = i + 1;
    }
}

// compile function def
fun compileFunction(funcNode : ^int) : void {
    retType : int;
    retStars : int;
    name : ^char;
    params : ^^int;
    paramCount : int;
    body : ^^int;
    bodyCount : int;
    i : int;
    temp : ^^int;
    param : ^int;
    paramType : int;
    paramStars : int;
    paramName : ^char;

    retType = getFunctionRetType(funcNode);
    retStars = getFunctionRetStars(funcNode);
    name = getFunctionName(funcNode);
    params = getFunctionParams(funcNode);
    paramCount = getFunctionParamCount(funcNode);
    body = getFunctionBody(funcNode);
    bodyCount = getFunctionBodyCount(funcNode);

    // hack for main()
    if (retType == TOKEN_INT() && retStars == 0) {
        temp_name : ^char;
        temp_name = name;
        if (^temp_name == 'm') {
            appendString("int ");
        } else {
            compileType(retType, retStars);
            appendChar(' ');
        }
    } else {
        compileType(retType, retStars);
        appendChar(' ');
    }

    appendString(name);
    appendChar('(');

    // params
    i = 0;
    while (i < paramCount) {
        temp = params + i;
        param = ^temp;

        paramType = getVariableBaseType(param);
        paramStars = getVariableStars(param);
        paramName = getVariableName(param);

        compileType(paramType, paramStars);
        appendChar(' ');
        appendString(paramName);

        if (i < paramCount - 1) {
            appendString(", ");
        }
        i = i + 1;
    }

    appendString(") {\n");

    // body
    indent();
    compileStatementBlock(body, bodyCount);
    dedent();

    appendString("}\n");
}

// file I/O helpers
fun readFile(filename : ^char) : ^char {
    file : ^char;
    buffer : ^char;
    size : int;
    bytesRead : int;

    // fopen, fseek, ftell, fread, fclose are C stdlib funcs
    file = fopen(filename, "r");
    if (file == 0) {
        puts("Error: cannot open file");
        return 0;
    }

    // get file size
    fseek(file, 0, 2);  // SEEK_END = 2
    size = ftell(file);
    fseek(file, 0, 0);  // SEEK_SET = 0

    // alloc buffer
    buffer = malloc(size + 1);

    // read file
    bytesRead = fread(buffer, 1, size, file);

    // null terminate
    temp : ^char;
    temp = buffer + bytesRead;
    ^temp = 0;

    fclose(file);
    return buffer;
}

// main entry - wire everything together
fun main(argc : int, argv : ^^char) : int {
    source : ^char;
    functionCount : int;
    argPtr : ^^char;
    filename : ^char;

    // check args
    if (argc < 2) {
        puts("Usage: shc_compiler <file.shc>");
        return 1;
    }

    // get filename from argv[1]
    argPtr = argv + 1;
    filename = ^argPtr;

    // read source file
    source = readFile(filename);
    if (source == 0) {
        return 1;
    }

    // init scanner
    initScanner(source);

    // parse program
    functionCount = parseProgram(source);

    // compile to C
    compile(parser_functions, functionCount);

    return 0;
}
